#include <Arduino.h>
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_TSL2561_U.h>
#include <Adafruit_NeoPixel.h>

/* ================== CONFIGURACIÓN DE HARDWARE ================== */
// NeoPixel
#define PIN_NEOPIXEL   23
#define NUM_PIXELS     1

// UART2 hacia STM32 (USART3 PC10/PC5)
#define UART2_RX_PIN   32   // RX del ESP32 <- TX del STM32
#define UART2_TX_PIN   33   // TX del ESP32 -> RX del STM32
#define UART2_BAUD     115200

// I2C para el sensor TSL2561 (SOLO ESP32 <-> SENSOR)
#define I2C_SDA        25
#define I2C_SCL        26

// LED integrado del ESP32
#define LED_PIN        2

/* ================== OBJETOS GLOBALES ================== */
Adafruit_NeoPixel pixels(NUM_PIXELS, PIN_NEOPIXEL, NEO_GRB + NEO_KHZ800);
Adafruit_TSL2561_Unified tsl = Adafruit_TSL2561_Unified(TSL2561_ADDR_FLOAT, 12345);

/* ================== VARIABLES GLOBALES ================== */
float lastLux   = 0.0f;
bool  sensorOK  = false;
unsigned long lastHeartbeat = 0;
unsigned long lastAutoRead  = 0;
int   commandCounter        = 0;

/* ================== FUNCIONES AUXILIARES ================== */

/**
 * @brief Enciende el NeoPixel con color (r,g,b). Si duracion > 0, lo apaga tras el tiempo.
 */
void setNeoPixel(uint8_t r, uint8_t g, uint8_t b, int duracion = 0) {
  pixels.setPixelColor(0, pixels.Color(r, g, b));
  pixels.show();
  if (duracion > 0) {
    delay(duracion);
    pixels.clear();
    pixels.show();
  }
}

/**
 * @brief Inicializa el sensor TSL2561 por I2C
 */
void initSensor() {
  Serial.println("\n[SENSOR] Inicializando TSL2561...");

  if (!tsl.begin()) {
    Serial.println("[ERROR] No se detecta el sensor TSL2561!");
    Serial.println("Verifica las conexiones:");
    Serial.println("  SDA -> GPIO25");
    Serial.println("  SCL -> GPIO26");
    sensorOK = false;

    // LED ROJO en NeoPixel para indicar error
    setNeoPixel(100, 0, 0, 2000);
    return;
  }

  sensorOK = true;
  Serial.println("[OK] Sensor TSL2561 detectado.");

  // Configuración recomendada
  tsl.enableAutoRange(true);                           // Auto-ganancia
  tsl.setIntegrationTime(TSL2561_INTEGRATIONTIME_13MS);

  sensor_t sensor;
  tsl.getSensor(&sensor);
  Serial.println("------------------------------------");
  Serial.print("Sensor:       "); Serial.println(sensor.name);
  Serial.print("Driver Ver:   "); Serial.println(sensor.version);
  Serial.print("Unique ID:    "); Serial.println(sensor.sensor_id);
  Serial.print("Max Value:    "); Serial.print(sensor.max_value); Serial.println(" lux");
  Serial.print("Min Value:    "); Serial.print(sensor.min_value); Serial.println(" lux");
  Serial.print("Resolution:   "); Serial.print(sensor.resolution); Serial.println(" lux");
  Serial.println("------------------------------------\n");

  // LED VERDE corto = sensor listo
  setNeoPixel(0, 100, 0, 500);
}

/**
 * @brief Lee el sensor TSL2561 vía I2C y devuelve cadena con el formato:
 *        "LUX:<valor>:OK" o un mensaje de error.
 */
String leerSensor() {
  if (!sensorOK) {
    return "ERROR_SENSOR_NO_INIT";
  }

  sensors_event_t event;
  tsl.getEvent(&event);

  if (event.light) {
    lastLux = event.light;
    String resultado = "LUX:";
    resultado += String(lastLux, 2);   // 2 decimales
    resultado += ":OK";
    return resultado;
  } else {
    return "ERROR_SENSOR_OVERFLOW";
  }
}

/* ================== SETUP ================== */

void setup() {
  // UART0 por USB para debug en la PC
  Serial.begin(115200);
  delay(2000);

  Serial.println("\n\n========================================");
  Serial.println("          ESP32 - PROYECTO 3");
  Serial.println("  Sensor TSL2561 (I2C) + UART con STM32");
  Serial.println("========================================");

  // LED integrado
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  // NeoPixel
  Serial.println("[INIT] Inicializando NeoPixel...");
  pixels.begin();
  pixels.setBrightness(50);
  pixels.clear();
  pixels.show();

  // Test rápido RGB
  setNeoPixel(100, 0, 0, 200);   // Rojo
  setNeoPixel(0, 100, 0, 200);   // Verde
  setNeoPixel(0, 0, 100, 200);   // Azul
  Serial.println("[OK] NeoPixel funcionando.");

  // I2C SOLO hacia el sensor (NO hacia la Nucleo)
  Serial.println("\n[INIT] Inicializando I2C para el sensor...");
  Wire.begin(I2C_SDA, I2C_SCL);
  Serial.print("  SDA: GPIO"); Serial.println(I2C_SDA);
  Serial.print("  SCL: GPIO"); Serial.println(I2C_SCL);

  // Inicializar TSL2561
  initSensor();

  // UART2 hacia STM32 (USART3 del STM32)
  Serial.println("\n[INIT] Inicializando UART2 (ESP32 <-> STM32)...");
  Serial2.begin(UART2_BAUD, SERIAL_8N1, UART2_RX_PIN, UART2_TX_PIN);
  Serial.print("  RX: GPIO"); Serial.println(UART2_RX_PIN);
  Serial.print("  TX: GPIO"); Serial.println(UART2_TX_PIN);
  Serial.print("  Baud: ");    Serial.println(UART2_BAUD);

  Serial.println("\n========================================");
  Serial.println("Sistema listo.");
  Serial.println("Esperando comando 'SOLICITUD_SENSOR' desde el STM32...");
  Serial.println("========================================\n");

  // NeoPixel AZUL = sistema listo
  setNeoPixel(0, 0, 100, 500);
}

/* ================== LOOP PRINCIPAL ================== */

void loop() {
  // Heartbeat cada 5 s en el monitor serie de debug
  if (millis() - lastHeartbeat > 5000) {
    lastHeartbeat = millis();
    Serial.println("[HEARTBEAT] ESP32 activo, esperando comandos por UART2...");
  }

  // Lectura automática opcional cada 10 s (solo debug, NO se envía al STM32)
  if (millis() - lastAutoRead > 10000) {
    lastAutoRead = millis();
    String lectura = leerSensor();
    Serial.print("[AUTO] Lectura local del sensor: ");
    Serial.println(lectura);
  }

  // ===== Revisión de comandos provenientes del STM32 por UART2 =====
  if (Serial2.available()) {
    // Leer hasta '\n' (el STM32 envía "SOLICITUD_SENSOR\r\n")
    String comando = Serial2.readStringUntil('\n');
    comando.trim();   // quita espacios, \r, etc.

    if (comando.length() > 0) {
      commandCounter++;

      Serial.println("\n========================================");
      Serial.print("[CMD #");
      Serial.print(commandCounter);
      Serial.println("] Comando recibido desde STM32:");
      Serial.print("  [");
      Serial.print(comando);
      Serial.println("]");

      // LED y NeoPixel indicando que se está procesando
      setNeoPixel(100, 100, 0);     // Amarillo
      digitalWrite(LED_PIN, HIGH);

      // ---- COMANDO PRINCIPAL: SOLICITUD DE LECTURA ----
      if (comando == "SOLICITUD_SENSOR") {
        Serial.println("[ACCION] Leer sensor TSL2561 y responder por UART2...");

        delay(100); // pequeño delay para simular tiempo de lectura

        String valor = leerSensor();

        Serial.print("[RESPUESTA] Valor leido: ");
        Serial.println(valor);

        // Enviar al STM32: el STM32 espera una línea terminada en '\n'
        Serial2.println(valor);
        Serial.println("[TX] Dato enviado al STM32 por UART2.");

        // NeoPixel VERDE = lectura correcta / respuesta enviada
        setNeoPixel(0, 100, 0, 500);
      }
      // ---- Comandos opcionales de prueba (por si los usas desde PC) ----
      else if (comando == "PING") {
        Serial.println("[ACCION] PING recibido.");
        Serial2.println("PONG");
        Serial.println("[TX] PONG enviado a STM32.");
        setNeoPixel(0, 100, 100, 300); // Cian
      }
      else if (comando == "STATUS") {
        Serial.println("[ACCION] STATUS solicitado.");
        String status = sensorOK ? "SENSOR_OK" : "SENSOR_ERROR";
        Serial2.println(status);
        Serial.println("[TX] STATUS enviado a STM32.");
        setNeoPixel(0, 100, 100, 300); // Cian
      }
      else {
        Serial.println("[WARNING] Comando no reconocido.");
        Serial2.println("ERROR_CMD_UNKNOWN");
        setNeoPixel(100, 50, 0, 500); // Naranja
      }

      digitalWrite(LED_PIN, LOW);
      Serial.println("========================================\n");
    }
  }

  delay(10);
}
