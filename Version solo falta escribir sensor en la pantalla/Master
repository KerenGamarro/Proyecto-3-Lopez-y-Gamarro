/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    main.c
  * @brief   STM32F446RE Maestro UART + ILI9341 + SD (FatFs)
  *
  * - STM32F446RE (Nucleo) <-> ESP32: SOLO UART
  *      UART2 (PA2/PA3)  -> PC (monitor serial, debug)
  *      UART3 (PC10/PC5) -> ESP32 (Serial2 en el ESP32)
  *
  * - ESP32:
  *      I2C <-> sensor (TSL2561 u otro) solo en el mundo ESP32.
  *      Recibe "SOLICITUD_SENSOR\r\n" por UART,
  *      lee el sensor por I2C,
  *      envía una cadena tipo "LUX:123.45:OK\r\n" al STM32.
  *
  * - STM32:
  *      * BTN (PC13 / BTN_Pin): envía "SOLICITUD_SENSOR\r\n" al ESP32,
  *        espera respuesta, la reenvía a la PC y actualiza el último dato.
  *      * BTNSAVE (PB2 / BTNSAVE_Pin): guarda el último dato recibido
  *        en "mediciones.txt" de la SD (append), actualiza la TFT y notifica
  *        al ESP32 con "SAVE_SD\r\n" para cambiar el NeoPixel.
  *
  * - Pantalla ILI9341 (240x320, interfaz paralela 8 bits):
  *      * Fondo fijo: bitmap 'fondo' (240x320) definido en bitmaps.c,
  *        dibujado directamente desde memoria (NO desde la SD),
  *        ocupando toda la pantalla.
  *      * Encima del fondo, en el centro, se dibuja un recuadro blanco
  *        donde se muestra el ÚLTIMO valor de sensor recibido
  *        con formato "LUX:xx.xx".
  *
  *   Parte 3: Despliegue de datos
  *      -> Se muestra el valor del sensor en la TFT, sobre el fondo.
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "fatfs.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <string.h>
#include <stdbool.h>
#include <stdio.h>
#include "ili9341.h"
#include "bitmaps.h"
#include "fatfs_sd.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* Dimensiones de la pantalla (ILI9341 en orientación 240x320) */
#define LCD_W  240
#define LCD_H  320

/* Dimensiones del bitmap de fondo (en bitmaps.c) */
#define FONDO_W 240
#define FONDO_H 320

/* Panel central para mostrar el valor del sensor */
#define PANEL_W   200
#define PANEL_H   60
#define PANEL_X   ((LCD_W - PANEL_W) / 2)
#define PANEL_Y   ((LCD_H - PANEL_H) / 2)

/* Colores RGB565 */
#define COL_FG     0x0000   /* Negro para texto */
#define COL_PANEL  0xFFFF   /* Fondo del panel (blanco) */
#define COL_FRAME  0x0000   /* Borde del panel */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */
/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
SPI_HandleTypeDef hspi1;

TIM_HandleTypeDef htim11;

UART_HandleTypeDef huart2;
UART_HandleTypeDef huart3;

/* USER CODE BEGIN PV */

/* Bitmap de fondo definido en bitmaps.c (240x320).
 * IMPORTANTE: tipo igual a bitmaps.h -> const uint8_t BITMAP_ALIGN fondo[]
 */
extern const uint8_t BITMAP_ALIGN fondo[];

/* Buffer de recepción desde el ESP32 */
uint8_t rxBuffer[200];

/* Flags de botones */
uint8_t btnPressed     = 0;
uint8_t btnSavePressed = 0;

/* Último dato válido recibido desde el ESP32, ya parseado como "LUX:xx.xx" */
static char   lastSensorStr[200] = {0};
static bool   lastSensorValid    = false;

/* SD / FatFs */
static uint8_t sd_mounted = 0;

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_SPI1_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_TIM11_Init(void);
static void MX_USART3_UART_Init(void);
/* USER CODE BEGIN PFP */

/* --- UI helpers --- */
static void UI_DrawBackground(void);
static void UI_DrawSensorPanel(const char *text);

/* --- SD helpers --- */
static void SD_Init(void);
static void SD_AppendLine(const char *line);

/* --- Parseo de cadena del sensor --- */
static void ParseSensorString(const char *src, char *dst, size_t dstSize);

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* Extrae solo "LUX:xx.xx" de una cadena tipo "LUX:xx.xx:OK" */
static void ParseSensorString(const char *src, char *dst, size_t dstSize)
{
    if (!src || !dst || dstSize == 0) return;

    char tmp[200];
    strncpy(tmp, src, sizeof(tmp) - 1);
    tmp[sizeof(tmp) - 1] = '\0';

    char *token1 = strtok(tmp, ":");      // "LUX"
    char *token2 = strtok(NULL, ":");     // "3.00"

    if (token1 && token2)
    {
        snprintf(dst, dstSize, "%s:%s", token1, token2);  // "LUX:3.00"
    }
    else
    {
        /* Si no tiene el formato esperado, copia todo */
        strncpy(dst, src, dstSize - 1);
        dst[dstSize - 1] = '\0';
    }
}

/* Dibuja el fondo usando el bitmap 'fondo' (240x320) desde bitmaps.c
 * NO se usa la SD para esta imagen.
 * Se dibuja UNA sola vez en el arranque.
 */
static void UI_DrawBackground(void)
{
    /* LCD_Bitmap espera unsigned char*, casteamos el puntero del bitmap. */
    LCD_Bitmap(0, 0, FONDO_W, FONDO_H, (unsigned char*)fondo);
}

/* Muestra el texto del sensor centrado dentro de un panel central.
 * Solo este panel se actualiza cada vez, el fondo no se toca.
 */
static void UI_DrawSensorPanel(const char *text)
{
    /* Fondo del panel (rectángulo sobre el fondo) */
    FillRect(PANEL_X, PANEL_Y, PANEL_W, PANEL_H, COL_PANEL);

    /* Borde del panel */
    Rect(PANEL_X, PANEL_Y, PANEL_W, PANEL_H, COL_FRAME);

    int fontSize = 3;              /* Tamaño grande para buena lectura */
    int charW    = 6 * fontSize;
    int charH    = 8 * fontSize;
    int len      = (text != NULL) ? (int)strlen(text) : 0;

    if (len == 0)
        return;

    int textW = len * charW;
    int x     = PANEL_X + (PANEL_W - textW) / 2;
    if (x < (PANEL_X + 2)) x = PANEL_X + 2;

    int y = PANEL_Y + (PANEL_H - charH) / 2;

    /* Firma de LCD_Print igual al proyecto que ya funciona:
       LCD_Print(text, x, y, size, colorTexto, colorFondo); */
    LCD_Print((char*)text, x, y, fontSize, COL_FG, COL_PANEL);
}

/* Inicializa y monta la SD (solo para guardar datos, NO para el fondo) */
static void SD_Init(void)
{
    /* MX_FATFS_Init() ya fue llamado en main. Aquí montamos la unidad. */
    FRESULT res = f_mount(&USERFatFS, USERPath, 1);

    if (res == FR_OK)
    {
        sd_mounted = 1;
        char msg[80];
        sprintf(msg, "[SD] Montaje exitoso.\r\n");
        HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), 1000);
    }
    else
    {
        sd_mounted = 0;
        char msg[80];
        sprintf(msg, "[SD] Error al montar (FRESULT=%d).\r\n", res);
        HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), 1000);
    }
}

/* Hace append de una línea a "mediciones.txt" si la SD está montada */
static void SD_AppendLine(const char *line)
{
    if (!sd_mounted) return;
    if (line == NULL || line[0] == '\0') return;

    FIL file;
    FRESULT res = f_open(&file, "mediciones.txt", FA_OPEN_APPEND | FA_WRITE);

    if (res == FR_OK)
    {
        UINT bw;
        f_write(&file, line, (UINT)strlen(line), &bw);
        f_close(&file);

        char msg[80];
        sprintf(msg, "[SD] Medicion guardada en mediciones.txt (bytes=%u).\r\n", (unsigned)bw);
        HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), 1000);
    }
    else
    {
        char msg[80];
        sprintf(msg, "[SD] Error al abrir mediciones.txt (FRESULT=%d).\r\n", res);
        HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), 1000);
    }
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */
  char msgPC[250];
  char msgESP[50];
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* Configure the system clock */
  SystemClock_Config();

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_SPI1_Init();
  MX_USART2_UART_Init();
  MX_FATFS_Init();
  MX_TIM11_Init();
  MX_USART3_UART_Init();

  /* USER CODE BEGIN 2 */

  HAL_Delay(500);

  /* Inicializa LCD y dibuja el fondo fijo desde bitmaps.c (240x320) */
  LCD_Init();
  UI_DrawBackground();

  /* Panel inicial con marcador "----" (solo texto, fondo ya está) */
  UI_DrawSensorPanel("----");

  /* Inicializa SD (solo para guardar mediciones) */
  SD_Init();

  /* Banner inicial por UART2 (PC) */
  sprintf(msgPC, "\r\n========================================\r\n");
  HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

  sprintf(msgPC, " STM32F446RE - Maestro UART + ILI9341 + SD\r\n");
  HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

  sprintf(msgPC, "  Data Logger con sensor I2C en ESP32 (servidor)\r\n");
  HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

  sprintf(msgPC, "========================================\r\n");
  HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

  sprintf(msgPC, "UART2 (PA2/PA3)  -> PC\r\n");
  HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

  sprintf(msgPC, "UART3 (PC10/PC5) -> ESP32\r\n");
  HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

  sprintf(msgPC, "BTN USER (PC13 / BTN_Pin): Solicitar lectura\r\n");
  HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

  sprintf(msgPC, "BTN SAVE (PB2 / BTNSAVE_Pin): Guardar ultimo dato en SD + SAVE_SD al ESP32\r\n");
  HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

  sprintf(msgPC, "========================================\r\n\r\n");
  HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

  sprintf(msgPC, "Sistema listo. Presione BTN USER para leer el sensor.\r\n\r\n");
  HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* ===== BOTÓN USER (BTN_Pin, PC13) -> Solicitar lectura al ESP32 ===== */
    if (HAL_GPIO_ReadPin(BTN_GPIO_Port, BTN_Pin) == GPIO_PIN_RESET && !btnPressed)
    {
      btnPressed = 1;
      HAL_Delay(50); // Debounce

      if (HAL_GPIO_ReadPin(BTN_GPIO_Port, BTN_Pin) == GPIO_PIN_RESET)
      {
        sprintf(msgPC, "\r\n>>> SOLICITUD DE LECTURA <<<\r\n");
        HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

        sprintf(msgPC, "[1] Enviando comando al ESP32 por UART3...\r\n");
        HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

        /* 1) Enviar solicitud al ESP32 */
        sprintf(msgESP, "SOLICITUD_SENSOR\r\n");
        HAL_UART_Transmit(&huart3, (uint8_t*)msgESP, strlen(msgESP), 1000);

        sprintf(msgPC, "[2] Esperando respuesta del ESP32...\r\n");
        HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

        /* 2) Esperar respuesta con timeout (bloqueante simple) */
        uint32_t startTime = HAL_GetTick();
        uint32_t timeout   = 3000;   // 3 segundos
        uint8_t  received  = 0;
        uint16_t idx       = 0;

        memset(rxBuffer, 0, sizeof(rxBuffer));

        while ((HAL_GetTick() - startTime) < timeout && !received)
        {
          uint8_t ch;
          if (HAL_UART_Receive(&huart3, &ch, 1, 100) == HAL_OK)
          {
            if (ch == '\n' || idx >= sizeof(rxBuffer) - 1)
            {
              rxBuffer[idx] = '\0';
              received = 1;
            }
            else
            {
              rxBuffer[idx++] = ch;
            }
          }
        }

        /* 3) Reenviar resultado a la PC + actualizar buffer interno */
        if (received)
        {
          sprintf(msgPC, "[3] Datos del sensor recibidos del ESP32: %s\r\n", rxBuffer);
          HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

          sprintf(msgPC, "[4] Datos reenviados a la PC por UART2.\r\n");
          HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

          /* Parsear para quedarnos solo con "LUX:xx.xx" y guardar como último dato */
          ParseSensorString((char*)rxBuffer, lastSensorStr, sizeof(lastSensorStr));
          lastSensorValid = true;

          /* Mostrar inmediatamente al leer en la TFT, sobre el cuadro blanco */
          UI_DrawSensorPanel(lastSensorStr);
        }
        else
        {
          sprintf(msgPC, "[ERROR] TIMEOUT - No se recibio respuesta del ESP32.\r\n");
          HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

          /* Mostrar error en la LCD */
          UI_DrawSensorPanel("ERR TIMEOUT");
        }

        sprintf(msgPC, "========================================\r\n\r\n");
        HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);
      }
    }

    /* Liberar flag cuando se suelta el botón USER */
    if (HAL_GPIO_ReadPin(BTN_GPIO_Port, BTN_Pin) == GPIO_PIN_SET)
    {
      btnPressed = 0;
    }

    /* ===== BOTÓN SAVE (BTNSAVE_Pin, PB2) -> Guardar en SD + MOSTRAR EN TFT + SAVE_SD ===== */
    if (HAL_GPIO_ReadPin(BTNSAVE_GPIO_Port, BTNSAVE_Pin) == GPIO_PIN_RESET && !btnSavePressed)
    {
      btnSavePressed = 1;
      HAL_Delay(50);

      if (HAL_GPIO_ReadPin(BTNSAVE_GPIO_Port, BTNSAVE_Pin) == GPIO_PIN_RESET)
      {
        if (lastSensorValid)
        {
          /* Línea a escribir en el archivo (dato + CRLF) */
          char line[260];
          snprintf(line, sizeof(line), "%s\r\n", lastSensorStr);
          SD_AppendLine(line);

          sprintf(msgPC,
                  "\r\n[BTN SAVE] Dato '%s' guardado en SD. Notificando al ESP32 (SAVE_SD).\r\n",
                  lastSensorStr);
          HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

          /* Actualizar inmediatamente la pantalla con el valor guardado */
          UI_DrawSensorPanel(lastSensorStr);

          /* Enviar comando SAVE_SD al ESP32 para cambiar NeoPixel a azul */
          char msgSave[] = "SAVE_SD\r\n";
          HAL_UART_Transmit(&huart3, (uint8_t*)msgSave, strlen(msgSave), 1000);
        }
        else
        {
          sprintf(msgPC, "\r\n[BTN SAVE] No hay medicion previa para guardar.\r\n");
          HAL_UART_Transmit(&huart2, (uint8_t*)msgPC, strlen(msgPC), 1000);

          /* Mensaje opcional en TFT */
          // UI_DrawSensorPanel("SIN DATO");
        }
      }
    }

    if (HAL_GPIO_ReadPin(BTNSAVE_GPIO_Port, BTNSAVE_Pin) == GPIO_PIN_SET)
    {
      btnSavePressed = 0;
    }

    HAL_Delay(10);
  }
  /* USER CODE END WHILE */

  /* USER CODE BEGIN 3 */
}
/* USER CODE END 3 */

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 80;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 2;
  RCC_OscInitStruct.PLL.PLLR = 2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{

  /* USER CODE BEGIN SPI1_Init 0 */

  /* USER CODE END SPI1_Init 0 */

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}

/**
  * @brief TIM11 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM11_Init(void)
{

  /* USER CODE BEGIN TIM11_Init 0 */

  /* USER CODE END TIM11_Init 0 */

  /* USER CODE BEGIN TIM11_Init 1 */

  /* USER CODE END TIM11_Init 1 */
  htim11.Instance = TIM11;
  htim11.Init.Prescaler = 0;
  htim11.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim11.Init.Period = 999;
  htim11.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim11.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim11) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM11_Init 2 */

  /* USER CODE END TIM11_Init 2 */

}

/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 9600;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/**
  * @brief USART3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{

  /* USER CODE BEGIN USART3_Init 0 */

  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
  huart3.Init.BaudRate = 9600;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /* ==========================
   *  ESTADOS INICIALES
   * ========================== */

  /* RST en HIGH (LCD listo) */
  HAL_GPIO_WritePin(LCD_RST_GPIO_Port, LCD_RST_Pin, GPIO_PIN_SET);

  /* Datos en A: D7, D0, D2 = 0 */
  HAL_GPIO_WritePin(GPIOA, LCD_D7_Pin | LCD_D0_Pin | LCD_D2_Pin, GPIO_PIN_RESET);

  /* WR y RD en HIGH (reposo) */
  HAL_GPIO_WritePin(GPIOA, LCD_WR_Pin | LCD_RD_Pin, GPIO_PIN_SET);

  /* RS en HIGH (modo datos por defecto) */
  HAL_GPIO_WritePin(LCD_RS_GPIO_Port, LCD_RS_Pin, GPIO_PIN_SET);

  /* CS de LCD y SS de SD en HIGH (no seleccionados) */
  HAL_GPIO_WritePin(GPIOB, LCD_CS_Pin | SD_SS_Pin, GPIO_PIN_SET);

  /* Datos en B: D6, D3, D5, D4 = 0 */
  HAL_GPIO_WritePin(GPIOB, LCD_D6_Pin | LCD_D3_Pin | LCD_D5_Pin | LCD_D4_Pin, GPIO_PIN_RESET);

  /* D1 en C = 0 */
  HAL_GPIO_WritePin(LCD_D1_GPIO_Port, LCD_D1_Pin, GPIO_PIN_RESET);

  /* ==========================
   *  CONFIGURACIÓN DE PINES
   * ========================== */

  /*Configure GPIO pin : BTN_Pin (PC13) */
  GPIO_InitStruct.Pin = BTN_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BTN_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : LCD_RST_Pin (PC1) */
  GPIO_InitStruct.Pin = LCD_RST_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
  HAL_GPIO_Init(LCD_RST_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LCD_RD_Pin LCD_WR_Pin LCD_D7_Pin LCD_D0_Pin LCD_D2_Pin (en GPIOA) */
  GPIO_InitStruct.Pin = LCD_RD_Pin | LCD_WR_Pin | LCD_D7_Pin | LCD_D0_Pin | LCD_D2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pin : LCD_RS_Pin (PA4) */
  GPIO_InitStruct.Pin = LCD_RS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
  HAL_GPIO_Init(LCD_RS_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LCD_CS_Pin SD_SS_Pin (PB0, PB6) */
  GPIO_InitStruct.Pin = LCD_CS_Pin | SD_SS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : BTNSAVE_Pin (PB2) */
  GPIO_InitStruct.Pin = BTNSAVE_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(BTNSAVE_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LCD_D6_Pin LCD_D3_Pin LCD_D5_Pin LCD_D4_Pin (PB10, PB3, PB4, PB5) */
  GPIO_InitStruct.Pin = LCD_D6_Pin | LCD_D3_Pin | LCD_D5_Pin | LCD_D4_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : LCD_D1_Pin (PC7) */
  GPIO_InitStruct.Pin = LCD_D1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(LCD_D1_GPIO_Port, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
