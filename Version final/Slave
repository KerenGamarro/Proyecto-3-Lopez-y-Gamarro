#include <Arduino.h>
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_TSL2561_U.h>
#include <Adafruit_NeoPixel.h>

/* ================== CONFIGURACIÓN HARDWARE ================== */
// Configuración del LED NeoPixel
#define PIN_NEOPIXEL   23
#define NUM_PIXELS     1

// Configuración del puerto UART2 para comunicarse con el STM32
#define UART2_RX_PIN   32
#define UART2_TX_PIN   33
#define UART2_BAUD     9600

// Pines del bus I2C para el sensor TSL2561
#define I2C_SDA        25
#define I2C_SCL        26

// LED integrado del ESP32
#define LED_PIN        2

/* ================== OBJETOS GLOBALES ================== */
// Objeto del NeoPixel
Adafruit_NeoPixel pixels(NUM_PIXELS, PIN_NEOPIXEL, NEO_GRB + NEO_KHZ800);

// Objeto del sensor de luz TSL2561
Adafruit_TSL2561_Unified tsl = Adafruit_TSL2561_Unified(TSL2561_ADDR_FLOAT, 12345);

/* ================== VARIABLES ================== */
// Guarda la última lectura de luz
float lastLux  = 0;

// Indica si el sensor fue configurado correctamente
bool  sensorOK = false;

// Variables para tiempos (mensajes y autolecturas)
unsigned long lastHeartbeat = 0;
unsigned long lastAutoRead  = 0;

// Contador de comandos recibidos vía UART
int   commandCounter        = 0;

/* ================== FUNCIONES DE ESTADO (NEOPIXEL) ================== */
/*
   Estas funciones controlan el color del NeoPixel para mostrar
   diferentes estados del sistema.
*/

// Cambia el color del LED NeoPixel (función base)
void setPixelColor(uint8_t r, uint8_t g, uint8_t b)
{
  pixels.setPixelColor(0, pixels.Color(r, g, b));
  pixels.show();
}

// Estado ROJO → sistema en reposo
void setStateIdle()
{
  setPixelColor(100, 0, 0);
}

// Estado AMARILLO → se recibió solicitud de lectura
void setStateRequest()
{
  setPixelColor(100, 100, 0);
}

// Estado VERDE → lectura realizada con éxito
void setStateOK()
{
  setPixelColor(0, 100, 0);
}

// Estado AZUL → comando de guardado (SAVE_SD)
void setStateSave()
{
  setPixelColor(0, 0, 100);
}

/* ================== SENSOR TSL2561 ================== */

// Inicializa el sensor TSL2561 (se llama en setup)
void initSensor()
{
  Serial.println("\n[SENSOR] Inicializando TSL2561...");

  // Si no se detecta el sensor, marca error
  if (!tsl.begin()) {
    Serial.println("[ERROR] No se detecta el TSL2561!");
    sensorOK = false;
    return;
  }

  // Si se detecta, configura el sensor
  sensorOK = true;
  Serial.println("[OK] Sensor detectado.");

  sensor_t sensor;
  tsl.enableAutoRange(true);                     // Ajuste automático del rango
  tsl.setIntegrationTime(TSL2561_INTEGRATIONTIME_13MS);  // Tiempo de integración
  tsl.getSensor(&sensor);                        // Obtiene info técnica del sensor

  // Imprime información del sensor
  Serial.println("------------------------------------");
  Serial.print("Sensor:       "); Serial.println(sensor.name);
  Serial.print("Driver Ver:   "); Serial.println(sensor.version);
  Serial.print("Unique ID:    "); Serial.println(sensor.sensor_id);
  Serial.print("Max Value:    "); Serial.print(sensor.max_value); Serial.println(" lux");
  Serial.print("Min Value:    "); Serial.print(sensor.min_value); Serial.println(" lux");
  Serial.print("Resolution:   "); Serial.print(sensor.resolution); Serial.println(" lux");
  Serial.println("------------------------------------\n");
}

/*
   leerSensor() se usa tanto para:
   - Autolectura en el loop (debug)
   - Responder al STM32 cuando envía SOLICITUD_SENSOR
*/
String leerSensor()
{
  if (!sensorOK) {
    return "ERROR_SENSOR_NO_INIT";
  }

  sensors_event_t event;
  tsl.getEvent(&event);

  // Si la lectura es válida
  if (event.light) {
    lastLux = event.light;

    String resultado = "LUX:";
    resultado += String(lastLux, 2);
    resultado += ":OK";

    return resultado;
  }

  // Si la lectura se saturó
  return "ERROR_SENSOR_OVERFLOW";
}

/* ================== SETUP ================== */
/*
   Aquí se inicializa todo:
   - Serial USB
   - NeoPixel
   - I2C
   - Sensor
   - UART2
   - Se fija el estado inicial (rojo)
*/

void setup()
{
  Serial.begin(115200);
  delay(2000);

  Serial.println("\n\n========================================");
  Serial.println("          ESP32 - PROYECTO 3");
  Serial.println("========================================");

  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  // Inicializa NeoPixel
  pixels.begin();
  pixels.setBrightness(50);
  pixels.clear();
  pixels.show();

  // Pequeña animación de prueba
  setPixelColor(100, 0, 0); delay(200);
  setPixelColor(0, 100, 0); delay(200);
  setPixelColor(0, 0, 100); delay(200);
  pixels.clear(); pixels.show();

  // Inicializar bus I2C
  Wire.begin(I2C_SDA, I2C_SCL);
  initSensor();     // ← SE LLAMA A LA FUNCIÓN QUE CONFIGURA EL SENSOR

  // Inicializar UART2 (comunicación con STM32)
  Serial2.begin(UART2_BAUD, SERIAL_8N1, UART2_RX_PIN, UART2_TX_PIN);

  // Estado inicial: IDLE (ROJO)
  setStateIdle();
}

/* ================== LOOP ================== */
/*
   El loop hace tres cosas principales:
   1) Mandar un "heartbeat" por Serial USB cada 5 s
   2) Hacer una lectura automática del sensor cada 10 s (debug)
   3) Escuchar comandos desde el STM32 y responderles
*/

void loop()
{
  // 1) Mensaje de vida por Serial
  if (millis() - lastHeartbeat > 5000) {
    lastHeartbeat = millis();
    Serial.println("[HEARTBEAT] ESP32 activo...");
  }

  // 2) Autolectura local cada 10 s (solo debug, no afecta al STM32)
  if (millis() - lastAutoRead > 10000) {
    lastAutoRead = millis();
    String lecturaLocal = leerSensor();   // ← SE LLAMA leerSensor()
    Serial.print("[AUTO] Lectura local: ");
    Serial.println(lecturaLocal);
  }

  // 3) Escucha comandos enviados desde el STM32
  if (Serial2.available()) {

    String comando = Serial2.readStringUntil('\n');
    comando.trim();
    commandCounter++;

    digitalWrite(LED_PIN, HIGH);

    // Si el STM32 pide una lectura del sensor
    if (comando.indexOf("SOLICITUD_SENSOR") >= 0) {

      setStateRequest();       // Amarillo
      delay(100);

      String valor = leerSensor();      // ← SE LLAMA leerSensor()
      Serial2.println(valor);           // Respuesta al STM32

      setStateOK();            // Verde
      delay(500);
      setStateIdle();          // Rojo
    }

    // Si el STM32 indica que guardó en SD
    else if (comando.indexOf("SAVE_SD") >= 0) {
      setStateSave();          // Azul
      delay(500);
      setStateIdle();
    }

    // Comando PING (debug)
    else if (comando.indexOf("PING") >= 0) {
      Serial2.println("PONG");
    }

    else {
      Serial2.println("ERROR_CMD_UNKNOWN");
    }

    digitalWrite(LED_PIN, LOW);
  }

  delay(10);
}
